<?php

use Drupal\comment\CommentInterface;
use Drupal\comment\Entity\Comment;
use Drupal\Component\Utility\Html;
use Drupal\Core\Ajax\AjaxResponse;
use Drupal\Core\Ajax\BaseCommand;
use Drupal\Core\Ajax\HtmlCommand;
use Drupal\Core\Ajax\ReplaceCommand;
use Drupal\Core\Cache\CacheableMetadata;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Url;

/**
 * Implements hook_form_ID_alter() for the form with ID 'comment_comment_form'.
 */
function comment_ajax_form_comment_comment_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form['actions']['comment_ajax__edit'] = [
    '#type' => 'submit',
    '#value' => t('Edit'),
    '#weight' => 100,
    '#attributes' => [
      'class' => ['js-show'],
      // @todo js-show defaults to "display: block;", the Baked theme should be updated to support this.
      'style' => ['display: inline-block;'],
    ],
  ];

  // Make the "Preview" button AJAX-enabled.
  $form['actions']['preview']['#ajax'] = [
    'callback' => 'comment_ajax_preview',
  ];

  // Create the placeholder for a comment preview: at the bottom of the form,
  // just before the form actions.
  $form['actions']['#prefix'] = '<div id="comment-ajax-preview-placeholder"></div>';

  // Make the "Save" button AJAX-enabled.
  $form['actions']['submit']['#ajax'] = [
    'callback' => 'comment_ajax_save',
  ];

  // Attach the corresponding JavaScript library.
  $form['actions']['preview']['#attached']['library'][] = 'comment_ajax/form';
}

function comment_ajax_preview($form, FormStateInterface $form_state) {
  // Simulate slowness.
  // sleep(5);

  // Render a preview of the comment.
  $form_object = $form_state->getFormObject();
  $comment = $form_object->getEntity();
  $comment->in_preview = TRUE;
  $output = comment_view($comment);

  $response = new AjaxResponse();
  $response->addCommand(new HtmlCommand('#comment-ajax-preview-placeholder', $output));
  return $response;
}

function comment_ajax_save($form, FormStateInterface $form_state) {
  // Simulate slowness.
  // sleep(5);

  // Execute the original CommentForm::save() logic.
  $form_object = $form_state->getFormObject();
  $form_object->save($form, $form_state);

  // Retrieve the redirect that CommentForm::save() performed, if any.
  $form_state->disableRedirect(FALSE);
  $redirect = $form_state->getRedirect();

  // Render the saved comment.
  $output = comment_view(Comment::load($form_object->getEntity()->id()));

  $response = new AjaxResponse();
  $response->addCommand(new ReplaceCommand('[data-drupal-selector="comment-form"]', $output));
  if ($redirect instanceof Url) {
    // Ensure the URL points to the anchor for the comment, just like it would
    // if this comment weren't posted via AJAX. This ensures the back button
    // behaves as expected.
    $response->addCommand(new BaseCommand('commentAjaxUpdateUrl', $redirect->toString(TRUE)->getGeneratedUrl()));
  }

  return $response;
}

/**
 * Implements hook_entity_view_alter().
 */
function comment_ajax_entity_view_alter(&$build, EntityInterface $entity, EntityViewDisplayInterface $display) {
  if ($entity instanceof CommentInterface) {
    // Only modify the markup and only attach the asset library if the current
    // user can in fact delete a comment. Ensure cacheability is updated
    // accordingly.
    $comment_delete_access = $entity->access('delete', NULL, TRUE);
    CacheableMetadata::createFromRenderArray($build)
      ->addCacheableDependency($comment_delete_access)
      ->applyTo($build);
    if ($comment_delete_access->isAllowed()) {
      $build['#attributes']['data-comment-ajax'] = $entity->id();
      $build['#attached']['library'][] = 'comment_ajax/delete';
    }
  }
}
